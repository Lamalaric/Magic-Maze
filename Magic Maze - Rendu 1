# -------------------------- Import ------------------------------ #
import os
import time
from upemtk import *
from random import *

# ------------------------- Fonctions ---------------------------- #

# ----------- Menu du jeu ------------ #

def affichageMenu():
	"""
	Créée le menu avec du texte et des rectangles servant de "boutons"
	"""
	global xy1_Jouer, xy2_Jouer, xy1_Rules, xy2_Rules, xy1_Close, xy2_Close
	## Titre du jeu ##
	efface_tout()
	image(largeur*nbCasesX/2 +largeur -15, 10, 'titreJeu.gif', ancrage="n")

	rectangle(largeur*2, largeur*3, nbCasesX*largeur, largeur*9.5, epaisseur = 3, couleur = 'red')

	texte((nbCasesX*largeur)/3.5, (nbCasesY*largeur)/3 +25, "Double-clic gauche sur un bouton", couleur="black", ancrage="w")
	## Bouton lançant le programme principal ##
	rectangle((nbCasesX*largeur)/4 +largeur/3, (nbCasesY*largeur)/2, (nbCasesX*largeur)/2 +largeur/3, (nbCasesY*largeur)/1.5, remplissage="black", tag = 'startButton')
	texte((nbCasesX*largeur)/4 +largeur*1.5 + 4, (nbCasesY*largeur)/2 + 37.5, "Jouer", couleur="white", ancrage="w", tag = 'start')
	xy1_Jouer = (nbCasesX*largeur/4)+largeur/3, (nbCasesY*largeur)/2
	xy2_Jouer = (nbCasesX*largeur/2)+largeur/3, (nbCasesY*largeur)/1.5
	## Bouton affichant les règles ##
	rectangle((nbCasesX*largeur)/4 +largeur/3 +largeur*5, (nbCasesY*largeur)/2, (nbCasesX*largeur)/2 +largeur*5 +largeur/3, (nbCasesY*largeur)/1.5, remplissage="black", tag = 'rulesButton')
	texte((nbCasesX*largeur)/4 +largeur*6.5 -4, (nbCasesY*largeur)/2 + 37.5, "Règles", couleur="white", ancrage="w", tag = 'rules')
	xy1_Rules = (nbCasesX*largeur/4) +largeur/3 +largeur*5, (nbCasesY*largeur)/2
	xy2_Rules = (nbCasesX*largeur/2) +largeur/3 +largeur*5, (nbCasesY*largeur)/1.5
	## Bouton quittant le jeu ##
	rectangle((nbCasesX*largeur)/2.5 +largeur/3, (nbCasesY*largeur)/1.4, (nbCasesX*largeur)/1.5 +largeur/3, (nbCasesY*largeur)/1.13, remplissage="black", tag = 'closeButton')
	texte((nbCasesX*largeur)/2.1 +largeur/3, (nbCasesY*largeur)/1.26, "Quitter", couleur="white", ancrage="w", tag = 'close')
	xy1_Close = (nbCasesX*largeur)/2.5 +largeur/3, (nbCasesY*largeur)/1.4
	xy2_Close = (nbCasesX*largeur)/1.5 +largeur/3, (nbCasesY*largeur)/1.13

def choixMenu():
	"""
	Compare les coordonnées du clic aux coordonnées des rectangles du menus.
	Si le clic est dans le rectangle "Jouer" : on lance le jeu.
	Si le clic est dans le rectangle "Règles" : on affiche les règles.
	"""
	coordClic = attente_clic()

	if coordClic[0] > xy1_Jouer[0] and coordClic[0] < xy2_Jouer[0]:
		if coordClic[1] > xy1_Jouer[1] and coordClic[1] < xy2_Jouer[1]:
			return 'Jouer'

	if coordClic[0] > xy1_Rules[0] and coordClic[0] < xy2_Rules[0]:
		if coordClic[1] > xy1_Rules[1] and coordClic[1] < xy2_Rules[1]:
			return 'Règles'

	if coordClic[0] > xy1_Close[0] and coordClic[0] < xy2_Close[0]:
		if coordClic[1] > xy1_Close[1] and coordClic[1] < xy2_Close[1]:
			return 'Quitter'

def rules():
	"""
	Affiche les règles du jeu
	"""
	efface_tout()

	texte(5, 25, "Règles du jeu:", couleur="red", ancrage="w")


	rectangle(largeur*(nbCasesX-2),largeur/2,largeur*nbCasesX +42.5, largeur*1.5, remplissage = 'black')
	texte(largeur*(nbCasesX-1.5),largeur, 'Retour', couleur = 'white', ancrage = 'w')
	coordClic = attente_clic()
	if coordClic[0] > largeur*(nbCasesX-2) and coordClic[0] < largeur*nbCasesX +42.5:
		if coordClic[1] > largeur/2 and coordClic[1] < largeur*1.5:
			affichageMenu()

# ---------- Partie Logique ---------- #

def creationMap(l, L) :
	"""
	Créer une fenêtre avec un nombre de cases en X et Y donné.
	Créer une matrice remplie de 0
	"""
	global nbCasesX, nbCasesY, largeur, Plateau 
	largeur = 50	# Largeur des carrés
	nbCasesX = l
	nbCasesY = L

	Plateau = []	# Création de la matrice
	for yAxes in range(nbCasesY):
		Plateau.append([])				# Dans chaque ligne du plateau
		for xAxes in range(nbCasesX):
			Plateau[yAxes].append(0)	# On met un 0, qui représente une case vide

	cree_fenetre((nbCasesX*largeur+75), (nbCasesY*largeur + 75))	# Création de la fenêtre

def creationPion():
	"""
	Définit la position de départ de chaque pion sur le plateau.
	Les pions sont contrôllés par les joueurs et doivent tous sortir avant la fin du temps impartit.
	"""
	pionVisé = 1
	midX = len(Plateau[0]) // 2 -1		# On stock où est la moitié de l'axe X
	midY = len(Plateau) // 2			# On stock où est la moitié de l'axe Y
	# On définit l'emplacement initial de chaque pion
	Plateau[midY-1][midX] = 1
	Plateau[midY-1][midX+1] = 2
	Plateau[midY][midX] = 3
	Plateau[midY][midX+1] = 4

def creationObjet():
	"""
	Génère 4 objets dans la matrice.
	Chaque joueur doit récupérer son objet.
	"""
	global posObjets
	idObjet = 11
	posObjets = []
	objetsCrées = 0

	while objetsCrées != 4:
		rdmY = randint(0,nbCasesY-1)
		rdmX = randint(0,nbCasesX-1)
		# On ajoute les objets un par un sur des cases libres.
		if Plateau[rdmY][rdmX] == 0 :
			Plateau[rdmY][rdmX] = idObjet
			posObjets.append((rdmY,rdmX))
			idObjet += 1
			objetsCrées += 1

def creationSortie():
	"""	
	Définit la position de la sortie
	"""
	rdmY = randint(0,nbCasesY-1)
	rdmX = randint(0,nbCasesX-1)
	sortieCréée=0
	while sortieCréée != 1:
	# On place une sortie sur une case libre.
		if Plateau[rdmY][rdmX] == 0 :
			Plateau[rdmY][rdmX] = 5
			sortieCréée+=1

def creationCaseVide(n) : 
	"""
	Génère n cases vides dans la matrice.
	Les joueurs ne peuvent pas aller sur les cases vides.
	"""
	caseVidesCrées = 0
	while caseVidesCrées != n :
		rdmY = randint(0,nbCasesY-1)
		rdmX = randint(0,nbCasesX-1)
		# On ajoute une case vide sur des cases libres.
		if Plateau[rdmY][rdmX] == 0 :
			Plateau[rdmY][rdmX] = 7
			caseVidesCrées += 1

def pionAimed(pionChoisi):
	"""
	Fonctionne avec la fonction pionSelected(i), qui permet de choisir le pion à actionner.
	Elle renvoie le pion séléctionné à bouger.
	"""
	global pionVisé
	pionVisé = pionChoisi
	pionVisé += 1
	# Lorsque appelé, le pion à actionner sera le supérieur au précédent
	if pionVisé > 4:
		pionVisé = 1
	return pionVisé

def isSortieOn(etatSortie):
	"""
	Active la sortie si tous les joueurs sont sur leur case objet.
	"""	
	if etatSortie == False :
		pionsSurObj = 0
		for yAxes in range(nbCasesY):
			for xAxes in range(nbCasesX):
				# +1 si un pion est sur sa case objet.
				if Plateau[yAxes][xAxes] == 1:
					if yAxes == posObjets[0][0] and xAxes == posObjets[0][1]:
						pionsSurObj += 1
				if Plateau[yAxes][xAxes] == 2:
					if yAxes == posObjets[1][0] and xAxes == posObjets[1][1]:
						pionsSurObj += 1
				if Plateau[yAxes][xAxes] == 3:
					if yAxes == posObjets[2][0] and xAxes == posObjets[2][1]:
						pionsSurObj += 1
				if Plateau[yAxes][xAxes] == 4:
					if yAxes == posObjets[3][0] and xAxes == posObjets[3][1]:
						pionsSurObj += 1
		# Si tous les pions sont sur leur case objet : sortie active
		if pionsSurObj == 4:
			for yAxes in range(nbCasesY):
				for xAxes in range(nbCasesX):
					if Plateau[yAxes][xAxes] == 5:
						Plateau[yAxes][xAxes] = 6
						return True
		return False
	return True

def isWin(pionsSortis, min, sec):
	"""
	Si les 4 joueurs ont atteints la sortie, la partie s'arrête et on à gagner.
	"""
	if pionsSortis == 4:
		gagner(minutes, secondes)

def actionTouche(player, objets, pionsSortis, debug):
	"""
	Gère les déplacements à faire selon chaque touche directionnelle appuyée.
	Selon la case à laquelle veut aller un pion, l'action sera différente.

	Cette fonction s'occupe également de récupérer la touche appuyée et exécuter l'action correspondante.
	"""
	global touche, pionVisé, pionsInSortie
	dejaVu = False
	touche = attente_touche_jusqua(1000)
	choixMove = ['Left', 'Right', 'Up', 'Down']
	choixPion = [1, 2, 3, 4]

	# Ferme la fenêtre si la touche appuyée est 'q'
	if touche == 'q' :
		ferme_fenetre()
	# Change de pion à bouger si la touche appuyée est 's'
	if touche == 's' :
		pionVisé = pionAimed(pionVisé)
	# Mode debug on/off
	if touche == 'd':
		debug = not debug
	if debug == True :		# Choix des mouvements / pions à actionner aléatoire
		touche = choixMove[randint(0,3)]
		player = choixPion[randint(0,3)]

	for yAxes in range(nbCasesY):
		for xAxes in range(nbCasesX):
			if Plateau[yAxes][xAxes] == player :

				## Aller à gauche ##
				if touche == 'Left':
					if xAxes > 0 :									# Si case visée is not 'bord du plateau'
						if Plateau[yAxes][xAxes-1] == 0 :				# Si case vide
							Plateau[yAxes][xAxes-1] = player
							Plateau[yAxes][xAxes] = 0
							break
						if Plateau[yAxes][xAxes-1] == player+10 :		# Si case visée = objet, compteur d'objets incrémenté de 1
							Plateau[yAxes][xAxes-1] = player
							Plateau[yAxes][xAxes] = 0
							debug = False
							break
						if Plateau[yAxes][xAxes-1] == 6 :				# Si case visée = sortie active, compteur pions sortis incrémenté de 1
							Plateau[yAxes][xAxes] = 0
							pionsInSortie += 1
							break

				## Aller à droite ##
				if touche == 'Right':
					if xAxes < nbCasesX-1 :							# Si case visée is not 'bord du plateau'
						if Plateau[yAxes][xAxes+1] == 0 :				# Si case vide
							Plateau[yAxes][xAxes+1] = player
							Plateau[yAxes][xAxes] = 0
							break
						if Plateau[yAxes][xAxes+1] == player+10 :		# Si case visée = objet, compteur d'objets incrémenté de 1
							Plateau[yAxes][xAxes+1] = player
							Plateau[yAxes][xAxes] = 0
							break
						if Plateau[yAxes][xAxes+1] == 6 :				# Si case visée = sortie active, compteur pions sortis incrémenté de 1
							Plateau[yAxes][xAxes] = 0
							pionsInSortie += 1
							break

				## Aller en haut ##
				if touche == 'Up':
					if yAxes > 0 :									# Si case visée is not 'bord du plateau'
						if Plateau[yAxes-1][xAxes] == 0:				# Si case vide
							Plateau[yAxes-1][xAxes] = player
							Plateau[yAxes][xAxes] = 0
							break
						if Plateau[yAxes-1][xAxes] == player+10 :		# Si objet, compteur d'objets incrémenté de 1
							Plateau[yAxes-1][xAxes] = player
							Plateau[yAxes][xAxes] = 0
							break
						if Plateau[yAxes-1][xAxes] == 6 :				# Si sortie active, compteur pions sortis incrémenté de 1
							Plateau[yAxes][xAxes] = 0
							pionsInSortie += 1
							break

				## Aller en bas ##
				if touche == 'Down':								
					if yAxes < nbCasesY-1 :								# Si case visée is not 'bord du plateau'
						if dejaVu == False :
							if Plateau[yAxes+1][xAxes] == 0 :				# Si case vide
									Plateau[yAxes+1][xAxes] = player
									Plateau[yAxes][xAxes] = 0
									dejaVu = True
									break
							if Plateau[yAxes+1][xAxes] == player+10 :		# Si objet, compteur d'objets incrémenté de 1
									Plateau[yAxes+1][xAxes] = player
									Plateau[yAxes][xAxes] = 0
									dejaVu = True
									break
							if Plateau[yAxes+1][xAxes] == 6 :				# Si sortie active, compteur pions sortis incrémenté de 1
									Plateau[yAxes][xAxes] = 0
									pionsInSortie += 1
									break
	return debug

# ---------- Partie visuelle ---------- #

def affichage() :
	"""
		Actualise l'affichage en fonction de chaque élément dans la matrice.
		Si l'elem. de la matrice est 0 : c'est une case libre alors on affiche un simple rectangle.
		Si l'elem. de la matrice est 5 : c'est la sortie alors on affiche l'image correspondante.
		Si l'elem. de la matrice est 7 : c'est une case vide alors on affiche un rectangle foncé
		Si l'elem. de la matrice est 1, 2, 3, 4 : c'est un pion alors on affiche l'image correspondante.
		Affiche les objets tant que la sortie n'est pas active.
	"""
	x, y = 0, 0
	for yAxes in range(nbCasesY):
		locY = yAxes*largeur-largeur/2+largeur
		for xAxes in range(nbCasesX):
			locX = xAxes*largeur-largeur/2+largeur
			## Affiche les cases libres ##
			rectangle(x, y, x+largeur, y+largeur, remplissage = 'light grey')
			# image(x+largeur//2, y+largeur//2, 'ground2.gif', ancrage = 'center')
			x += largeur
			## Affiche les pions ##
			if Plateau[yAxes][xAxes] == 1 :
				image(locX, locY, 'Warrior_pion_transp.gif', ancrage = 'center', tag = 'warrior')
			if Plateau[yAxes][xAxes] == 2 : 
				image(locX, locY, 'Wizzard_pion_transp.gif', ancrage = 'center', tag = 'wizzard')
			if Plateau[yAxes][xAxes] == 3 : 
				image(locX, locY, 'Elf_pion_transp.gif', ancrage = 'center', tag = 'elf')
			if Plateau[yAxes][xAxes] == 4 : 
				image(locX, locY, 'Dwarf_pion_transp.gif', ancrage = 'center', tag = 'dwarf')
			## Affiche les objets tant que la sortie n'est pas active ##
			if yAxes == posObjets[0][0] and xAxes == posObjets[0][1]:	
				if not sortieOn:
					image(locX, locY, 'Warrior_objet_transp.gif', ancrage = 'center', tag = 'warriorObj')	
			if yAxes == posObjets[1][0] and xAxes == posObjets[1][1]:
				if not sortieOn:
					image(locX, locY, 'Wizzard_objet_transp.gif', ancrage = 'center', tag = 'wizzardObj')
			if yAxes == posObjets[2][0] and xAxes == posObjets[2][1]:
				if not sortieOn:
					image(locX, locY, 'Elf_objet_transp.gif', ancrage = 'center', tag = 'elfObj')
			if yAxes == posObjets[3][0] and xAxes == posObjets[3][1]:
				if not sortieOn: 
					image(locX, locY, 'Dwarf_objet_transp.gif', ancrage = 'center', tag = 'dwarfObj')
			## Affiche sortie on ou off ##
			if Plateau[yAxes][xAxes] == 5 : 
				image(locX+1, locY, 'Vortex_transp_off.gif', ancrage = 'center', tag = 'exitOff')
			if Plateau[yAxes][xAxes] == 6 : 
				image(locX+1, locY, 'Vortex_transp_on.gif', ancrage = 'center', tag = 'exitOn')
			## Affiche les cases vides ##
			if Plateau[yAxes][xAxes] == 7 :
				rectangle(xAxes*largeur, yAxes*largeur, xAxes*largeur+largeur, yAxes*largeur+largeur, remplissage = 'dark grey', tag = 'caseVide')
		x = 0
		y += largeur

def pionSelected(i):
	"""
	Affiche les icônes de pions sur le côté, ainsi qu'un rond indiquant quel pion est séléctionné.
	"""
	# Affiche le rond de séléction
	cercle(nbCasesX*largeur +37, largeur*1 +(i-1)*largeur, 25, epaisseur = 2, couleur = 'red')
	#Affiche les icônes propres à chaque pion
	image(nbCasesX*largeur +37, largeur*1, 'Warrior_pion_transp.gif', ancrage = 'center')
	image(nbCasesX*largeur +37, largeur*2, 'Wizzard_pion_transp.gif', ancrage = 'center')
	image(nbCasesX*largeur +37, largeur*3, 'Elf_pion_transp.gif', ancrage = 'center')
	image(nbCasesX*largeur +37, largeur*4 -6, 'Dwarf_pion_transp.gif', ancrage = 'center')

def objetsLeft(sortie):
	"""
	Affiche sur le côté les objets restants à voler sur le côté.
	"""
	# Affiche les objets manquants tant que la sortie n'est pas active
	if not sortie:
		image(nbCasesX*largeur +37, (nbCasesY*largeur)/2 + 1*largeur, 'Warrior_objet_transp.gif', ancrage = 'center', tag= 'WarriorObjetPrit')
		image(nbCasesX*largeur +37, (nbCasesY*largeur)/2 + 2*largeur, 'Wizzard_objet_transp.gif', ancrage = 'center', tag= 'WizzardObjetPrit')
		image(nbCasesX*largeur +37, (nbCasesY*largeur)/2 + 3*largeur, 'Elf_objet_transp.gif', ancrage = 'center', tag= 'ElfObjetPrit')
		image(nbCasesX*largeur +37, (nbCasesY*largeur)/2 + 4*largeur, 'Dwarf_objet_transp.gif', ancrage = 'center', tag= 'DwarfObjetPrit')
	if sortie:
		image(nbCasesX*largeur +37, (nbCasesY*largeur)/2 + 2*largeur +largeur/2, 'Vortex_transp_on.gif', ancrage = 'center', tag= 'SortieOn')
	# Efface l'objet sur le côté si le pion est dessus
	for yAxes in range(nbCasesY):
		for xAxes in range(nbCasesX):
			if Plateau[yAxes][xAxes] == 1:
				if yAxes == posObjets[0][0] and xAxes == posObjets[0][1]:
					efface('WarriorObjetPrit')
			if Plateau[yAxes][xAxes] == 2:
				if yAxes == posObjets[1][0] and xAxes == posObjets[1][1]:
					efface('WizzardObjetPrit')
			if Plateau[yAxes][xAxes] == 3:
				if yAxes == posObjets[2][0] and xAxes == posObjets[2][1]:
					efface('ElfObjetPrit')
			if Plateau[yAxes][xAxes] == 4:
				if yAxes == posObjets[3][0] and xAxes == posObjets[3][1]:
					efface('DwarfObjetPrit')

def timer(seconde, startTime) :
	"""
	Affiche un timer décroissant en secondes, depuis le nombre rentré en paramètre.
	"""
	global minutes, secondes
	secElapsed = int((time.time() - startTime)) # Secondes écoulées depuis le début du programme
	secLeft = seconde - secElapsed				# Secondes restantes
	couleur = 'dark green'
	# Conversion du temps en minutes:secondes
	minutes = secLeft // 60
	secondes = secLeft - minutes*60

	if minutes < 0:		# Si le temps tombe à 0, partie perdue.
		perdu()
	if minutes == 0 and secondes < 30:			# Si - de 30sec restantes : couleur rouge
		couleur = 'red'
	#Affichage du temps restant en secondes
	texte(largeur//2, nbCasesY*largeur+37.5, "Temps restant: " + str(minutes) + "min" + str(secondes), couleur=couleur, taille = 20, tag = "timer", ancrage = 'w')

def instructions():
	"""
	Affiche sous forme de texte les actions que le joueur peut faire
	"""
	texte(largeur*6 +longueur_texte(minutes+secondes)+longueur_texte('min')-10, nbCasesY*largeur+12, "Commandes:", couleur='black', taille = 14, ancrage = 'w')
	texte(largeur*6 +longueur_texte(minutes+secondes)+longueur_texte('min') +27.5, nbCasesY*largeur+30, "s : Changer de pion à déplacer", couleur='black', taille = 12, ancrage = 'w')
	texte(largeur*6 +longueur_texte(minutes+secondes)+longueur_texte('min') +27.5, nbCasesY*largeur+50, "←↑→↓ : Déplacer le pion séléctionné", couleur='black', taille = 12, ancrage = 'w')
	texte(largeur*6 +290 +longueur_texte(minutes+secondes)+longueur_texte('min') +27.5, nbCasesY*largeur+30, "q : Quitter le jeu", couleur='black', taille = 12, ancrage = 'w')
	texte(largeur*6 +290 +longueur_texte(minutes+secondes)+longueur_texte('min') +27.5, nbCasesY*largeur+50, "d : Débug mode (on/off)", couleur='black', taille = 12, ancrage = 'w')

def affichageDroit():
	pionSelected(pionVisé)
	ligne(nbCasesX*largeur +7, (nbCasesY*largeur)/2, nbCasesX*largeur +68, (nbCasesY*largeur)/2, couleur='black', epaisseur=3)
	objetsLeft(sortieOn)

def affichageBas():
	timer(180, startTime)
	ligne(largeur*5.3+longueur_texte(minutes+secondes)+longueur_texte('min'), nbCasesY*largeur+12, largeur*5.3+longueur_texte(minutes+secondes)+longueur_texte('min'), nbCasesY*largeur+65, couleur='black', epaisseur=3)
	instructions()

def perdu():
	"""
	Si tous les pions ne sont pas sortis avant la fin du temps impartit, on arrête la partie et on affiche les texte de fin.
	Partie perdue.
	"""
	while 1 :
		texte((nbCasesX//2+1)*largeur, (nbCasesY//2-1)*largeur, "Temps écoulé, perdu..", couleur="red", ancrage = "center", taille = 45)
		texte((nbCasesX//2+1)*largeur, (nbCasesY//1.5)*largeur, "Vous ferez mieux la prochaine fois, retentez votre chance!", couleur="black", ancrage = "center", taille = 25)
		attente_clic()
		break
	ferme_fenetre()

def gagner(min, sec):
	"""
	Si tous les pions sont sortis, on arrête la partie et on affiche les texte de fin
	Partie gagnée.
	"""
	s = 60-sec
	while 1 :
		efface_tout()
		texte((nbCasesX//2+1)*largeur, (nbCasesY//2-1)*largeur, "Vous avez gagné!", couleur="dark green", ancrage = "center", taille = 45)
		texte((nbCasesX//2+1)*largeur, (nbCasesY//1.5)*largeur, "Félicitations, vous avez finit le jeu en " + str(min) + "min" + str(s), couleur="black", ancrage = "center", taille = 25)
		attente_clic()
		break	
	ferme_fenetre()

# ----------------------- Main Program --------------------------- #
if __name__ == '__main__':
	# Initialisations variables
	creationMap(16,10)
	
	while 1:
		affichageMenu()

		if choixMenu() == 'Règles':
			rules()

		if choixMenu() == 'Quitter':
			ferme_fenetre()

		if choixMenu() == 'Jouer':
			startTime = time.time()
			sortieOn = False
			pionVisé = 1
			objetsOwn = 0
			pionsInSortie = 0
			debugMode = False
	
			# Création entités
			creationPion()
			creationObjet()
			creationSortie()
			creationCaseVide(20)
	
			# Boucle principale
			while 1:
				affichageBas()
				affichageDroit()
				affichage()
	
				isWin(pionsInSortie, minutes, secondes)
				sortieOn = isSortieOn(sortieOn)
				debugMode = actionTouche(pionVisé, objetsOwn, pionsInSortie, debugMode)
				
				mise_a_jour()
				efface_tout()

# GRISER L'IMAGE DU PION QUAND IL NE PEUT PLUS ETRE SELECTIONNER (quand il est sortit) #
