#------------------------- Import -------------------------------
import time
from upemtk import *


#------------------------- Fonctions ----------------------------


def creationMap(l, L) :       # Création de la fenetre pour faire la map


	global largeur, nbCasesX, nbCasesY, Plateau
	
	nbCasesX = l
	nbCasesY = L
	largeur = 50		# Largeur des carrés

	cree_fenetre((nbCasesX*largeur+1), (nbCasesY*largeur + 100))		# Création de la fenêtre

	
	Plateau = []

	x, y = 0, 0

	for yAxes in range(nbCasesY):
		Plateau.append([])

		for xAxes in range(nbCasesX):
			Plateau[yAxes].append(rectangle(x, y, x+largeur, y+largeur, remplissage = 'light grey'))
			x += largeur
		
		x = 0
		y += largeur



# def timer(temps,seconde, startTime) :
# 	minutesLeft = temps
# 	secondeLeft= seconde

# 	secElapsed = int((time.time() - startTime))		# Secondes écoulées depuis le début du programme
# 	timeElapsed = minutesLeft, ':', (secondeLeft - secElapsed)	# Stock le temps restant

# 	texte(50, 50, timeElapsed, couleur="red")	# Affiche le temps restant

# 	if (secondeLeft - secElapsed) == -1 :
# 		minutesLeft -= 1
# 		secondeLeft = 59
# 		startTime = time.time()



def creationPion():

	global PionB, PionG, PionR,PionY 		# Initialisation des variables pour les pions

	PionB = Plateau.append(cercle(25,25,20))


	# PionB =cercle( ((nbCasesX//2)*largeur) - (largeur//2),  ((nbCasesY//2)*largeur) - (largeur//2), 17, remplissage="blue")
	# PionG =cercle( ((nbCasesX//2)*largeur) - (largeur//2),  ((nbCasesY//2+1)*largeur) - (largeur//2), 17, remplissage="green")
	# PionR =cercle( ((nbCasesX//2+1)*largeur) - (largeur//2),  ((nbCasesY//2+1)*largeur) - (largeur//2), 17, remplissage="red")
	# PionY =cercle( ((nbCasesX//2+1)*largeur) - (largeur//2),  ((nbCasesY//2)*largeur) - (largeur//2), 17, remplissage="yellow")


def deplacement_touches():

	while True:
		evenement = donne_evenement()
		type_ev = type_evenement(evenement)

		if type_ev == 'Touche':
			nom_touche = touche(evenement)

			if nom_touche == 'z':
				efface(PionB)
				PionB =cercle( ((nbCasesX//2)*largeur) - (largeur//2),  (((nbCasesY//2+1)*largeur) - (largeur//2)) - 50, 17, remplissage="green")

	
		mise_a_jour()   



def movePionB() :

	while True:
		evenement = donne_evenement()
		type_ev = type_evenement(evenement)

		if type_ev == 'Touche':
			nom_touche = touche(evenement)

			if nom_touche == 'z':
				efface(PionB)
				PionB =cercle( ((nbCasesX//2)*largeur) - (largeur//2),  (((nbCasesY//2+1)*largeur) - (largeur//2)) - 50, 17, remplissage="blue")

		mise_a_jour()


def perdu():

	while 1 :
		texte((nbCasesX//2+1)*largeur, (nbCasesY//2-1)*largeur, "Partie perdue", couleur="red", ancrage = "center", taille = 45)
		attente_clic()
		break	
	ferme_fenetre()


# def touchetap():
# 	while True:
# 		evenement = donne_evenement()			# Récupère la touche appuyée
# 		type_ev = type_evenement(evenement)		# Renvoie en str la touche appuyée

# 		if type_ev == 'Touche':							# Comparaison de la touche
# 			touchPressed = print(touche(evenement))		# Afficher la touche appuyée


# 		mise_a_jour() # Actualise la fenêtre



#------------------------- Main Program -------------------------

if __name__ == '__main__':
	# startTime = time.time()		# Secondes depuis 1970 (pour timer())

	creationMap(10,15)
	creationPion()
	attente_clic()
	ferme_fenetre()
