#------------------------- Import -------------------------------
import time
from upemtk import *


#------------------------- Fonctions ----------------------------


# ----- Partie Logique -----

def creationMap(l, L) :


	global nbCasesX, nbCasesY, Plateau, largeur
	
	nbCasesX = l
	nbCasesY = L
	largeur = 50		# Largeur des carrés

	cree_fenetre((nbCasesX*largeur+1), (nbCasesY*largeur + 100))		# Création de la fenêtre

	
	Plateau = []
	# Création de la matrice
	for yAxes in range(nbCasesY):
		Plateau.append([])

		for xAxes in range(nbCasesX):
			Plateau[yAxes].append(0)



def creationPion():

	global midX, midY

	midX = len(Plateau[0]) // 2 -1		# On stock où est la moitié de l'axe X
	midY = len(Plateau) // 2			# On stock où est la moitié de l'axe Y

	# On définit l'emplacement initial de chaque pion
	Plateau[midY-1][midX] = 1
	Plateau[midY-1][midX+1] = 2
	Plateau[midY][midX] = 3
	Plateau[midY][midX+1] = 4




# ----- Partie visuelle -----

def affichage() :

	# Actualise l'affichage en fonction de chaque élément dans la matrice

	x, y = 0, 0
	for yAxes in range(nbCasesY):
		for xAxes in range(nbCasesX):
			rectangle(x, y, x+largeur, y+largeur, remplissage = 'light grey')

			if (Plateau[yAxes][xAxes] == 1 or
			Plateau[yAxes][xAxes] == 2 or
			Plateau[yAxes][xAxes] == 3 or
			Plateau[yAxes][xAxes] == 4):

				cercle(xAxes*largeur-largeur/2+largeur, yAxes*largeur-largeur/2+largeur, 20)

			x += largeur

		x = 0
		y += largeur




def timer(temps,seconde, startTime) :
	minutesLeft = temps
	secondeLeft= seconde

	secElapsed = int((time.time() - startTime))					# Secondes écoulées depuis le début du programme
	timeLeft = minutesLeft, ':', (secondeLeft - secElapsed)		# Stock le temps restant

	effacer(timer)												# Effacer l'ancien temps			
	texte(50, 50, timeLeft, couleur="red", tag = "timer")		# Affiche le temps restant

	if (secondeLeft - secElapsed) == -1 :
		minutesLeft -= 1
		secondeLeft = 59
		startTime = time.time()

	return timeLeft

def deplacement_touches():
	
	
	while True :
		test=attente_clic_ou_touche()

		if test == 'Left':
			
			for yAxes in range(len(Plateau[0])):


				for xAxes in range(len(Plateau)):
				
				
					
						
		return Plateau





# def touchetap():

# 	while True:
# 		evenement = donne_evenement()			# Récupère la touche appuyée
# 		type_ev = type_evenement(evenement)		# Renvoie en str la touche appuyée

# 		if type_ev == 'Touche':							# Comparaison de la touche
# 			touchPressed = print(touche(evenement))		# Afficher la touche appuyée


# 		mise_a_jour() # Actualise la fenêtre




def perdu():

	while 1 :
		texte((nbCasesX//2+1)*largeur, (nbCasesY//2-1)*largeur, "Partie perdue", couleur="red", ancrage = "center", taille = 45)
		attente_clic()
		break	
	ferme_fenetre()




#------------------------- Main Program -------------------------

if __name__ == '__main__':
	# startTime = time.time()		# Secondes depuis 1970 (pour timer())



	creationMap(10,15)
	creationPion()


	while 1 :
		#deplacement_touches()
		print(Plateau)
		affichage()
		timer()
		# if timeElapsed == 0 :
		# 	texte(perdu...)
		# 	break
	

	attente_clic()
	ferme_fenetre()
			
